<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DCAUtils.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DCAUtils.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation-and-Usage"><span>Installation and Usage</span></a></li><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DCAUtils.jl-documentation"><a class="docs-heading-anchor" href="#DCAUtils.jl-documentation">DCAUtils.jl documentation</a><a id="DCAUtils.jl-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#DCAUtils.jl-documentation" title="Permalink"></a></h1><p>This package contains some utilities for <a href="https://en.wikipedia.org/wiki/Direct_coupling_analysis">Direct Coupling Analysis</a>, an unsupervised technique to analyse Multiple Sequence Alignments of protein families.</p><p>The code is written in <a href="http://julialang.org">Julia</a>. It requires Julia <code>1.5</code> or later.</p><h2 id="Installation-and-Usage"><a class="docs-heading-anchor" href="#Installation-and-Usage">Installation and Usage</a><a id="Installation-and-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Installation-and-Usage" title="Permalink"></a></h2><p>To install the package, use Julia&#39;s package manager: from the Julia REPL, type <code>]</code> to enter the Pkg REPL mode and run:</p><pre><code class="language-none">(v1.5) pkg&gt; add DCAUtils</code></pre><p>Then load it with:</p><pre><code class="language-none">julia&gt; using DCAUtils</code></pre><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>The functions in this package are written to maximize performance. Most computationally-heavy functions can use multiple threads (start julia with the <code>-t</code> option or set the <code>JULIA_NUM_THREADS</code> environment variable). In most cases such functions need to perform operations over every pair of sequences or every pair of resiudes; since such operations are symmetric, only the upper-triangular part is needed, and a custom parallelization scheme is used for this purpose. During these parallel parts of the code, BLAS parallelization is disabled, and it is restored at the end.</p><p>On top of parallelization, big efficiency gains can be had in certain operations by working with a compressed representation of the data. The general idea is that the multiple sequence alignment is first parsed and converted into a <code>Matrix{Int8}</code> representation (see <a href="#DCAUtils.ReadFastaAlignment.read_fasta_alignment"><code>read_fasta_alignment</code></a>). Then, internally, functions such as <a href="#DCAUtils.compute_weights"><code>compute_weights</code></a> and <a href="#DCAUtils.compute_dists"><code>compute_dists</code></a> further explot the assumption that no value larger than <code>31</code> will appear, thus requiring 5 bits at the most: thus, they pack each sequence of <span>$N$</span> <code>Int8</code> values into <span>$⌈N / 12⌉$</span> <code>UInt64</code> values. Efficient bit-wise operations are then applied to compute the Hamming distance between sequences, processing 12 entries at a time.</p><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DCAUtils.ReadFastaAlignment.read_fasta_alignment" href="#DCAUtils.ReadFastaAlignment.read_fasta_alignment"><code>DCAUtils.ReadFastaAlignment.read_fasta_alignment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_fasta_alignment(filename::AbstractString, max_gap_fraction::Real) -&gt; Matrix{Int8}</code></pre><p>Parses a FASTA file containing a multiple sequence alignment, and returns a matrix of integers that represents one sequence per column.</p><p>The mapping between the aminoacid symbols and the integers uses this table:</p><pre><code class="language-none">  A  C  D  E  F  G  H  I  K  L  M  N  P  Q  R  S  T  V  W  Y
  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20</code></pre><p>Any unrecognized capital letter and the gap symbol <code>-</code> are mapped to the value 21; any other symbol or lowercase letter is ignored.</p><p>If a sequence contains a fraction of gaps that exceeds <code>max_gap_fraction</code>, it is discarded. Set this value to 1 to keep all the sequences.</p><p>The input file can be plaintext (ASCII) or gzip-compressed plaintext (with the extension &quot;.gz&quot;)</p><p>See also <a href="#DCAUtils.remove_duplicate_sequences"><code>remove_duplicate_sequences</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/120beb65cd72d0e900ba981554723ed924110717/src/read_fasta_alignment.jl#L10-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DCAUtils.remove_duplicate_sequences" href="#DCAUtils.remove_duplicate_sequences"><code>DCAUtils.remove_duplicate_sequences</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_duplicate_sequences(Z::Matrix{Int8}; verbose::Bool = true) -&gt; (Matrix{Int8}, Vector{Int})</code></pre><p>Takes a matrix representing a mutiple sequence alignment (see <a href="#DCAUtils.ReadFastaAlignment.read_fasta_alignment"><code>read_fasta_alignment</code></a>) and returns a new matrix with all duplicated sequences removed. It also returns a vector of column indices with the positions of the unique sequences in the input matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/120beb65cd72d0e900ba981554723ed924110717/src/DCAUtils.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DCAUtils.compute_theta" href="#DCAUtils.compute_theta"><code>DCAUtils.compute_theta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_theta(Z::Matrix{Int8}) -&gt; Float64</code></pre><p>This function computes the threshold as used by the <code>:auto</code> setting of <a href="#DCAUtils.compute_weights"><code>compute_weights</code></a> (but it is more efficient computationally to use the <code>:auto</code> option than to invoke this function and passing the result to <code>compute_weights</code>).</p><p>It computes the mean value <span>$ϕ$</span> of the similarity fraction between all possible pairs of sequences in <code>Z</code> (the similarity fraction is the number of equal entries divided by the length of the sequences).</p><p>The result is then computed as <span>$θ = \min(0.5, 0.1216 / ϕ)$</span>.</p><p>This function can use multiple threads if available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/120beb65cd72d0e900ba981554723ed924110717/src/compute_theta.jl#L84-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DCAUtils.compute_weights" href="#DCAUtils.compute_weights"><code>DCAUtils.compute_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_weights(Z::Matrix{Int8}, [q::Integer,] θ; verbose::Bool = true) -&gt; (Vector{Float64}, Float64)</code></pre><p>This function computes the reweighting vector. It retuns the vector and its sum <code>Meff</code> (the latter represents the number of &quot;effective&quot; sequences).</p><p><code>Z</code> is an <span>$N × M$</span> multiple sequence aLignment (see <a href="#DCAUtils.ReadFastaAlignment.read_fasta_alignment"><code>read_fasta_alignment</code></a>). <span>$N$</span> is the length of each sequence and <span>$M$</span> the number of sequences.</p><p><code>q</code> is the maximum value in the alphabet, if omitted it&#39;s computed from <code>maximum(Z)</code>.</p><p><code>θ</code> is the distance threshold: for any sequence, the number <span>$n$</span> of sequences (including itself) that are at normalized distance smaller than <span>$⌊θN⌋$</span> is counted, and the weight of that sequence is then <span>$1/n$</span>.</p><p><code>θ</code> can be a real value between 0 and 1, or the symbol <code>:auto</code>, in which case the <a href="#DCAUtils.compute_theta"><code>compute_theta</code></a> function is used.</p><p>This function can use multiple threads if available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/120beb65cd72d0e900ba981554723ed924110717/src/compute_weights.jl#L81-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DCAUtils.compute_dists" href="#DCAUtils.compute_dists"><code>DCAUtils.compute_dists</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_dists(Z::Matrix{Int8}) -&gt; Matrix{Float64}</code></pre><p>This function computes the matrix of normalized Hamming distances between sequences of the multiple sequence alignment <code>Z</code> (see <a href="#DCAUtils.ReadFastaAlignment.read_fasta_alignment"><code>read_fasta_alignment</code></a>).</p><p>This function can use multiple threads if available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/120beb65cd72d0e900ba981554723ed924110717/src/compute_dists.jl#L84-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DCAUtils.compute_weighted_frequencies" href="#DCAUtils.compute_weighted_frequencies"><code>DCAUtils.compute_weighted_frequencies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_weighted_frequencies(Z::Matrix{Int8}, W::Vector{Float64} [, q]) -&gt; (Vector{Float64}, Matrix{Float64})</code></pre><p>Given a multiple sequence alignment matrix <code>Z</code> (see <a href="#DCAUtils.ReadFastaAlignment.read_fasta_alignment"><code>read_fasta_alignment</code></a>), and a vector of weights (see <a href="#DCAUtils.compute_weights"><code>compute_weights</code></a>), returns the empirical one- and two-point frequencies <span>$P_i$</span> and <span>$P_{ij}$</span>.</p><p><code>q</code> is the size of the alphabet, if not given it&#39;s computed as <code>maximum(Z)</code>.</p><p>If <code>Z</code> has size <span>$N × M$</span> (i.e. <span>$M$</span> sequences of length <span>$N$</span>), the resulting vector <span>$P_i$</span> has length <span>$N (q-1)$</span> and contains <span>$N$</span> blocks (one for each residue position), each block containing the frequencies of the amino-acids, weighted according to <code>W</code>. The frequency of the last symbol, which usually represents the gap, is omitted and can be recovered by normalization. The resulting matrix <span>$P_{ij}$</span> has size <span>$N (q-1) × N (q-1)$</span> and it also has a block structure, with <span>$N × N$</span> blocks, one for each pair of residues (the last row and column of each block are omitted and can be recovered by normalization).</p><pre><code class="language-none">compute_weighted_frequencies(Z::Matrix{Int8}, [q,] θ) -&gt; (Vector{Float64}, Matrix{Float64}, Float64, Vector{Float64})</code></pre><p>This form of the function just calls <a href="#DCAUtils.compute_weights"><code>compute_weights</code></a> with the given values of <code>θ</code> and <code>q</code> and then uses the result to call the version desrcibed above.</p><p>Besides returning the one- and two-point frequencies, it also returns the result of <code>compute_weights</code>: the <code>Meff</code> and the reweighting vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/120beb65cd72d0e900ba981554723ed924110717/src/compute_weighted_frequencies.jl#L29-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DCAUtils.add_pseudocount" href="#DCAUtils.add_pseudocount"><code>DCAUtils.add_pseudocount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_pseudocount(Pi::Vector{Float64}, Pij::Matrix{Float64}, pc::Float64, q::Integer = 21) -&gt; (Vector{Float64}, Matrix{Float64})</code></pre><p>This function takes one- and two-points frequencies (see <a href="#DCAUtils.compute_weighted_frequencies"><code>compute_weighted_frequencies</code></a>) and returns the corresponding frequencies with a pseudocount <code>pc</code> added.</p><p>The resulting frequencies are the same that would be obtained by mixing the original data with weight <code>(1-pc)</code> with a uniform distribution with weight <code>pc</code>. So <code>pc</code> must be between 0 (returns a copy of the original data) and 1 (returns the frequencies for the uniform distribution).</p><p>The integer <code>q</code> is used to specify the block size of the matrices (each block has size <span>$(q-1)×(q-1)$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/120beb65cd72d0e900ba981554723ed924110717/src/DCAUtils.jl#L80-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DCAUtils.compute_DI_gauss" href="#DCAUtils.compute_DI_gauss"><code>DCAUtils.compute_DI_gauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_DI_gauss(J::Matrix{Float64}, C::Matrix{Float64}, q::Integer = 21) -&gt; Matrix{Float64}</code></pre><p>Compute the Direct Information matrix, assuming a Gaussian model.</p><p><code>C</code> is the covariance matrix <span>$C_{ij} = P_{ij} - P_i P_j$</span>, and <code>J</code> its inverse.</p><p>The integer <code>q</code> is used to specify the block size of the matrices (each block has size <span>$(q-1)×(q-1)$</span>). The result has one entry per block.</p><p>This function can use multiple threads if available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/120beb65cd72d0e900ba981554723ed924110717/src/compute_DI_gauss.jl#L33-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DCAUtils.compute_FN" href="#DCAUtils.compute_FN"><code>DCAUtils.compute_FN</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_FN(J::Matrix{Float64}, q::Integer = 21) -&gt; Matrix{Float64}</code></pre><p>Compute the matrix of Frobenius norms.</p><p><code>J</code> is the inverse of the covariance matrix <span>$C_{ij} = P_{ij} - P_i P_j$</span>.</p><p>The integer <code>q</code> is used to specify the block size of the matrices (each block has size <span>$(q-1)×(q-1)$</span>). The result has one entry per block.</p><p>This function can use multiple threads if available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/carlobaldassi/DCAUtils.jl/blob/120beb65cd72d0e900ba981554723ed924110717/src/compute_FN.jl#L1-L12">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 19 February 2021 18:29">Friday 19 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
